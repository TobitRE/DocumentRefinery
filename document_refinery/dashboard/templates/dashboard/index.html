{% extends "dashboard/base.html" %}

{% block title %}Document Refinery — Ops Dashboard{% endblock %}

{% block header_extra %}
  <div class="card" style="padding: 16px 18px;">
    <div class="row" style="justify-content: space-between;">
      <div style="min-width: min(420px, 100%); display: grid; gap: 8px;">
        <label for="apiKeyInput" class="muted" style="text-transform: uppercase; letter-spacing: 0.12em; font-size: 12px;">API key</label>
        <input id="apiKeyInput" placeholder="Api-Key ..." autocomplete="off" />
        <div class="actions">
          <button id="saveKeyBtn">Save key</button>
          <button class="secondary" id="refreshBtn">Refresh data</button>
        </div>
        <div class="row muted" style="gap: 10px;">
          <label class="pill" style="cursor: pointer;">
            <input type="checkbox" id="autoRefresh" />
            Auto-refresh (10s)
          </label>
          <span>Last update: <span id="lastUpdated">—</span></span>
        </div>
        <div class="muted" id="statusLine">Waiting for API key.</div>
      </div>
    </div>
  </div>
{% endblock %}

{% block content %}
  <section class="grid">
    <div class="card">
      <h3>Queued</h3>
      <div class="stat" id="statQueued">—</div>
    </div>
    <div class="card">
      <h3>Running</h3>
      <div class="stat" id="statRunning">—</div>
    </div>
    <div class="card">
      <h3>Succeeded</h3>
      <div class="stat" id="statSucceeded">—</div>
    </div>
    <div class="card">
      <h3>Failed</h3>
      <div class="stat" id="statFailed">—</div>
    </div>
  </section>

  <section class="grid">
    <div class="card">
      <h3>Durations (24h)</h3>
      <div class="list">
        <div class="mono">Avg: <span id="statAvg">—</span> ms</div>
        <div class="mono">P50: <span id="statP50">—</span> ms</div>
        <div class="mono">P95: <span id="statP95">—</span> ms</div>
        <div class="mono">Total: <span id="statTotal">—</span> ms</div>
      </div>
    </div>
    <div class="card">
      <h3>Stages running</h3>
      <div class="list" id="stagesRunning">No active stages.</div>
    </div>
    <div class="card">
      <h3>Workers</h3>
      <div class="list" id="workerList">—</div>
    </div>
    <div class="card">
      <h3>System status</h3>
      <div class="list" id="systemStatus">—</div>
    </div>
    <div class="card">
      <h3>Metrics (internal)</h3>
      <pre class="metrics" id="metricsText">—</pre>
    </div>
  </section>

  <section class="grid">
    <div class="card">
      <h3>Upload document</h3>
      <div class="form-grid">
        <div class="field">
          <label for="uploadFile">PDF file</label>
          <input type="file" id="uploadFile" accept="application/pdf" />
        </div>
        <div class="field">
          <label for="uploadExternalUuid">External UUID (optional)</label>
          <input type="text" id="uploadExternalUuid" placeholder="e.g. 2f3b12aa-7c4b-4d2e-8a01-8b9d6b6d8d4f" />
        </div>
        <div class="field">
          <label for="uploadProfile">Profile (optional)</label>
          <select id="uploadProfile">
            <option value="">No profile</option>
            <option value="fast_text">fast_text</option>
            <option value="ocr_only">ocr_only</option>
            <option value="structured">structured</option>
            <option value="full_vlm">full_vlm</option>
          </select>
        </div>
        <div class="field">
          <label for="uploadOptionsJson">Docling options JSON (optional)</label>
          <textarea id="uploadOptionsJson" placeholder='{"max_num_pages": 50, "exports": ["markdown","text"]}'></textarea>
        </div>
        <div class="field">
          <label>Testset after upload</label>
          <div class="list">
            <label class="pill">
              <input type="checkbox" id="uploadCompare" />
              Create comparison across profiles
            </label>
            <div class="muted">If no profile is selected, all profiles are used.</div>
            <div class="row">
              <label class="pill"><input type="checkbox" name="uploadCompareProfiles" value="fast_text" /> fast_text</label>
              <label class="pill"><input type="checkbox" name="uploadCompareProfiles" value="ocr_only" /> ocr_only</label>
              <label class="pill"><input type="checkbox" name="uploadCompareProfiles" value="structured" /> structured</label>
              <label class="pill"><input type="checkbox" name="uploadCompareProfiles" value="full_vlm" /> full_vlm</label>
            </div>
          </div>
        </div>
        <div class="field">
          <label for="uploadCompareOptionsJson">Testset options JSON (optional)</label>
          <textarea id="uploadCompareOptionsJson" placeholder='{"max_num_pages": 50}'></textarea>
        </div>
        <div class="row">
          <label class="pill">
            <input type="checkbox" id="uploadIngest" checked />
            Start ingestion
          </label>
        </div>
        <div class="actions">
          <button id="uploadBtn">Upload</button>
          <button class="ghost" id="clearUploadBtn" type="button">Clear</button>
        </div>
        <div class="panel" id="uploadResult">No upload yet.</div>
      </div>
    </div>

    <div class="card">
      <h3>Job status</h3>
      <div class="form-grid">
        <div class="field">
          <label for="jobIdInput">Job ID</label>
          <input type="text" id="jobIdInput" placeholder="Enter job id to fetch" />
        </div>
        <div class="actions">
          <button class="secondary" id="fetchJobBtn">Fetch status</button>
          <button class="ghost" id="togglePollBtn" type="button">Start polling</button>
        </div>
        <div class="panel" id="jobStatusPanel">No job loaded.</div>
        <div class="actions" id="jobActions"></div>
        <div class="panel" id="artifactPanel">No artifacts.</div>
      </div>
    </div>

    <div class="card">
      <h3>Compare profiles</h3>
      <div class="form-grid">
        <div class="field">
          <label for="compareDocumentId">Document ID</label>
          <input type="text" id="compareDocumentId" placeholder="Document id to compare" />
        </div>
        <div class="field">
          <label>Profiles</label>
          <div class="list" id="profileList">
            <div class="row">
              <label class="pill"><input type="checkbox" name="compareProfiles" value="fast_text" /> fast_text</label>
              <span class="muted">Born-digital PDFs, lowest latency.</span>
              <span class="pill">Speed: fast</span>
              <span class="pill">Quality: medium</span>
            </div>
            <div class="row">
              <label class="pill"><input type="checkbox" name="compareProfiles" value="ocr_only" /> ocr_only</label>
              <span class="muted">Scanned PDFs, OCR-only.</span>
              <span class="pill">Speed: medium</span>
              <span class="pill">Quality: text only</span>
            </div>
            <div class="row">
              <label class="pill"><input type="checkbox" name="compareProfiles" value="structured" /> structured</label>
              <span class="muted">OCR + tables/layout focus.</span>
              <span class="pill">Speed: slower</span>
              <span class="pill">Quality: high</span>
            </div>
            <div class="row">
              <label class="pill"><input type="checkbox" name="compareProfiles" value="full_vlm" /> full_vlm</label>
              <span class="muted">OCR + tables + image enrichment.</span>
              <span class="pill">Speed: slowest</span>
              <span class="pill">Quality: highest</span>
            </div>
          </div>
          <div class="panel muted">
            Recommendation: born-digital documents → <span class="mono">fast_text</span>. Scanned
            documents → <span class="mono">ocr_only</span>. If you need tables or layout fidelity,
            try <span class="mono">structured</span> or <span class="mono">full_vlm</span>.
          </div>
        </div>
        <div class="field">
          <label for="compareOptionsJson">Options JSON (optional)</label>
          <textarea id="compareOptionsJson" placeholder='{"max_num_pages": 50}'></textarea>
        </div>
        <div class="actions">
          <button class="secondary" id="compareRunBtn">Run comparison</button>
        </div>
        <div class="field">
          <label for="compareIdInput">Comparison ID</label>
          <input type="text" id="compareIdInput" placeholder="Paste comparison id to fetch jobs" />
        </div>
        <div class="actions">
          <button class="ghost" id="compareFetchBtn" type="button">Fetch jobs</button>
        </div>
        <div class="panel" id="compareResult">No comparison yet.</div>
      </div>
    </div>
  </section>

  <section class="card">
    <h3>Comparison review</h3>
    <div class="list">
      <div class="row">
        <label class="pill"><input type="checkbox" id="compareFilterErrors" /> Show errors only</label>
        <label class="pill"><input type="checkbox" id="compareDiffOnly" /> Show only changes</label>
        <span class="muted">Diff uses a limited line window for large outputs.</span>
      </div>
      <div class="panel" id="comparisonSummary">No comparison loaded.</div>
      <div class="row">
        <div class="field" style="min-width: 220px;">
          <label for="compareJobA">Job A</label>
          <select id="compareJobA"></select>
        </div>
        <div class="field" style="min-width: 220px;">
          <label for="compareJobB">Job B</label>
          <select id="compareJobB"></select>
        </div>
        <div class="field" style="min-width: 220px;">
          <label for="compareArtifactKind">Artifact kind</label>
          <select id="compareArtifactKind">
            <option value="markdown">markdown</option>
            <option value="text">text</option>
            <option value="doctags">doctags</option>
            <option value="docling_json">docling_json</option>
          </select>
        </div>
        <div class="actions">
          <button class="secondary" id="compareLoadBtn" type="button">Load previews</button>
          <button class="ghost" id="compareClearBtn" type="button">Clear</button>
        </div>
      </div>
      <div class="grid">
        <div class="panel">
          <div class="muted">Preview A</div>
          <pre class="metrics" id="comparePreviewA">No preview loaded.</pre>
        </div>
        <div class="panel">
          <div class="muted">Preview B</div>
          <pre class="metrics" id="comparePreviewB">No preview loaded.</pre>
        </div>
      </div>
      <div class="panel metrics" id="compareDiffPanel">No diff yet.</div>
    </div>
  </section>

  <section class="card">
    <h3>Recent failures</h3>
    <div class="list" id="recentFailures">—</div>
  </section>
{% endblock %}

{% block scripts %}
  <script>
    const statusLine = document.getElementById("statusLine");
    const apiKeyInput = document.getElementById("apiKeyInput");
    const saveKeyBtn = document.getElementById("saveKeyBtn");
    const refreshBtn = document.getElementById("refreshBtn");
    const autoRefresh = document.getElementById("autoRefresh");
    const lastUpdated = document.getElementById("lastUpdated");
    const uploadFile = document.getElementById("uploadFile");
    const uploadExternalUuid = document.getElementById("uploadExternalUuid");
    const uploadProfile = document.getElementById("uploadProfile");
    const uploadOptionsJson = document.getElementById("uploadOptionsJson");
    const uploadCompare = document.getElementById("uploadCompare");
    const uploadCompareOptionsJson = document.getElementById("uploadCompareOptionsJson");
    const uploadIngest = document.getElementById("uploadIngest");
    const uploadBtn = document.getElementById("uploadBtn");
    const clearUploadBtn = document.getElementById("clearUploadBtn");
    const uploadResult = document.getElementById("uploadResult");
    const jobIdInput = document.getElementById("jobIdInput");
    const fetchJobBtn = document.getElementById("fetchJobBtn");
    const togglePollBtn = document.getElementById("togglePollBtn");
    const jobStatusPanel = document.getElementById("jobStatusPanel");
    const jobActions = document.getElementById("jobActions");
    const artifactPanel = document.getElementById("artifactPanel");
    const compareDocumentId = document.getElementById("compareDocumentId");
    const compareOptionsJson = document.getElementById("compareOptionsJson");
    const compareRunBtn = document.getElementById("compareRunBtn");
    const compareIdInput = document.getElementById("compareIdInput");
    const compareFetchBtn = document.getElementById("compareFetchBtn");
    const compareResult = document.getElementById("compareResult");
    const comparisonSummary = document.getElementById("comparisonSummary");
    const compareFilterErrors = document.getElementById("compareFilterErrors");
    const compareDiffOnly = document.getElementById("compareDiffOnly");
    const compareJobA = document.getElementById("compareJobA");
    const compareJobB = document.getElementById("compareJobB");
    const compareArtifactKind = document.getElementById("compareArtifactKind");
    const compareLoadBtn = document.getElementById("compareLoadBtn");
    const compareClearBtn = document.getElementById("compareClearBtn");
    const comparePreviewA = document.getElementById("comparePreviewA");
    const comparePreviewB = document.getElementById("comparePreviewB");
    const compareDiffPanel = document.getElementById("compareDiffPanel");
    let pollTimer = null;
    let comparisonJobs = [];
    const comparisonArtifacts = new Map();
    const comparisonStats = new Map();
    const comparisonTextCache = new Map();
    let lastDiffPayload = null;
    const ALL_PROFILES = ["fast_text", "ocr_only", "structured", "full_vlm"];

    const fields = {
      queued: document.getElementById("statQueued"),
      running: document.getElementById("statRunning"),
      succeeded: document.getElementById("statSucceeded"),
      failed: document.getElementById("statFailed"),
      avg: document.getElementById("statAvg"),
      p50: document.getElementById("statP50"),
      p95: document.getElementById("statP95"),
      total: document.getElementById("statTotal"),
      stages: document.getElementById("stagesRunning"),
      workers: document.getElementById("workerList"),
      system: document.getElementById("systemStatus"),
      failures: document.getElementById("recentFailures"),
      metrics: document.getElementById("metricsText"),
    };

    function setStatus(message, isError = false) {
      statusLine.textContent = message;
      statusLine.className = isError ? "error" : "muted";
    }

    function loadSavedKey() {
      const saved = localStorage.getItem("docrefinery_api_key");
      if (saved) {
        apiKeyInput.value = saved;
      }
    }

    function saveKey() {
      localStorage.setItem("docrefinery_api_key", apiKeyInput.value.trim());
      setStatus("API key saved.");
    }

    async function fetchJson(path) {
      const key = apiKeyInput.value.trim();
      if (!key) {
        setStatus("Add an API key to load data.", true);
        throw new Error("missing key");
      }
      const res = await fetch(path, {
        headers: {
          Authorization: `Api-Key ${key}`,
        },
      });
      if (!res.ok) {
        const msg = `Request failed (${res.status})`;
        setStatus(msg, true);
        throw new Error(msg);
      }
      return res.json();
    }

    async function fetchAuthorized(path, options = {}) {
      const key = apiKeyInput.value.trim();
      if (!key) {
        setStatus("Add an API key to load data.", true);
        throw new Error("missing key");
      }
      const headers = options.headers || {};
      headers.Authorization = `Api-Key ${key}`;
      return fetch(path, { ...options, headers });
    }

    function renderSummary(data) {
      fields.queued.textContent = data.jobs.queued ?? 0;
      fields.running.textContent = data.jobs.running ?? 0;
      fields.succeeded.textContent = data.jobs.succeeded ?? 0;
      fields.failed.textContent = data.jobs.failed ?? 0;
      fields.avg.textContent = data.durations_ms.avg_24h ?? "—";
      fields.p50.textContent = data.durations_ms.p50_24h ?? "—";
      fields.p95.textContent = data.durations_ms.p95_24h ?? "—";
      fields.total.textContent = data.durations_ms.total_24h ?? "—";

      const stages = data.stages_running || {};
      const stageEntries = Object.entries(stages);
      fields.stages.innerHTML = stageEntries.length
        ? stageEntries
            .map(
              ([name, count]) =>
                `<div class="pill">${name.toLowerCase()}: ${count}</div>`
            )
            .join("")
        : "No active stages.";

      const failures = data.recent_failures || [];
      fields.failures.innerHTML = failures.length
        ? failures
            .map(
              (item) =>
                `<div class="pill">Job ${item.id} · ${item.error_code || "UNKNOWN"}</div>`
            )
            .join("")
        : "No recent failures.";
    }

    function renderWorkers(data) {
      const workers = data.workers || [];
      fields.workers.innerHTML = workers.length
        ? workers
            .map(
              (worker) =>
                `<div class="pill">${worker.hostname} · ${worker.active_tasks} active</div>`
            )
            .join("")
        : "No workers online.";
    }

    function formatBytes(bytes) {
      if (bytes === null || bytes === undefined) return "—";
      const units = ["B", "KB", "MB", "GB", "TB"];
      let idx = 0;
      let value = bytes;
      while (value >= 1024 && idx < units.length - 1) {
        value /= 1024;
        idx += 1;
      }
      return `${value.toFixed(1)} ${units[idx]}`;
    }

    function formatPercent(value) {
      if (value === null || value === undefined) return "—";
      return `${value.toFixed(1)}%`;
    }

    function formatUptime(seconds) {
      if (!seconds && seconds !== 0) return "—";
      const days = Math.floor(seconds / 86400);
      const hours = Math.floor((seconds % 86400) / 3600);
      const mins = Math.floor((seconds % 3600) / 60);
      if (days > 0) return `${days}d ${hours}h`;
      if (hours > 0) return `${hours}h ${mins}m`;
      return `${mins}m`;
    }

    function formatDuration(ms) {
      if (ms === null || ms === undefined) return "—";
      if (ms < 1000) return `${ms} ms`;
      return `${(ms / 1000).toFixed(1)} s`;
    }

    function clearNode(node) {
      while (node.firstChild) {
        node.removeChild(node.firstChild);
      }
    }

    function createPill(text) {
      const pill = document.createElement("span");
      pill.className = "pill";
      pill.textContent = text;
      return pill;
    }

    function jobUsesOcr(profile) {
      return ["ocr_only", "structured", "full_vlm"].includes(profile);
    }

    function truncateText(text, limit = 5000) {
      if (!text) return { text: "", truncated: false };
      if (text.length <= limit) return { text, truncated: false };
      return { text: `${text.slice(0, limit)}\n…(truncated)…`, truncated: true };
    }

    async function loadArtifacts(jobId) {
      if (comparisonArtifacts.has(jobId)) {
        return comparisonArtifacts.get(jobId);
      }
      const artifacts = await fetchJson(`/v1/artifacts/?job_id=${jobId}`);
      comparisonArtifacts.set(jobId, artifacts);
      return artifacts;
    }

    async function loadArtifactText(jobId, kind) {
      const cacheKey = `${jobId}:${kind}`;
      if (comparisonTextCache.has(cacheKey)) {
        return comparisonTextCache.get(cacheKey);
      }
      const artifacts = await loadArtifacts(jobId);
      const artifact = artifacts.find((item) => item.kind === kind);
      if (!artifact) {
        comparisonTextCache.set(cacheKey, null);
        return null;
      }
      const res = await fetchAuthorized(`/v1/artifacts/${artifact.id}/`);
      if (!res.ok) {
        comparisonTextCache.set(cacheKey, null);
        return null;
      }
      const text = await res.text();
      comparisonTextCache.set(cacheKey, text);
      return text;
    }

    async function loadJobStats(job) {
      if (comparisonStats.has(job.id)) {
        return comparisonStats.get(job.id);
      }
      const stats = {
        pages: null,
        ocr_pages: null,
        pictures: null,
        tables: null,
        text_chars: null,
        chars_per_page: null,
        confidence: "unknown",
        artifacts: 0,
      };
      const artifacts = await loadArtifacts(job.id);
      stats.artifacts = artifacts.length;

      const doclingRaw = await loadArtifactText(job.id, "docling_json");
      if (doclingRaw) {
        try {
          const data = JSON.parse(doclingRaw);
          stats.pages = Array.isArray(data.pages) ? data.pages.length : stats.pages;
          stats.pictures = Array.isArray(data.pictures) ? data.pictures.length : stats.pictures;
          if (Array.isArray(data.tables)) {
            stats.tables = data.tables.length;
          } else if (Array.isArray(data.table_structures)) {
            stats.tables = data.table_structures.length;
          }
        } catch (err) {
          // Ignore malformed docling JSON.
        }
      }

      const textRaw = await loadArtifactText(job.id, "text");
      if (textRaw) {
        stats.text_chars = textRaw.length;
        if (stats.pages) {
          stats.chars_per_page = Math.round(stats.text_chars / Math.max(1, stats.pages));
        }
      }

      if (stats.pages !== null && jobUsesOcr(job.profile)) {
        stats.ocr_pages = stats.pages;
      }

      if (job.status && job.status !== "SUCCEEDED") {
        stats.confidence = "failed";
      } else if (stats.chars_per_page !== null && stats.chars_per_page < 200) {
        stats.confidence = "low";
      } else if (stats.chars_per_page !== null) {
        stats.confidence = "ok";
      }

      comparisonStats.set(job.id, stats);
      return stats;
    }

    function populateComparisonSelects(jobs) {
      const prevA = compareJobA.value;
      const prevB = compareJobB.value;
      compareJobA.innerHTML = "";
      compareJobB.innerHTML = "";
      const placeholderA = document.createElement("option");
      placeholderA.value = "";
      placeholderA.textContent = "Select job A";
      const placeholderB = document.createElement("option");
      placeholderB.value = "";
      placeholderB.textContent = "Select job B";
      compareJobA.appendChild(placeholderA);
      compareJobB.appendChild(placeholderB);

      jobs.forEach((job) => {
        const label = `Job ${job.id} · ${job.profile || "—"} · ${job.status || "—"}`;
        const optA = document.createElement("option");
        optA.value = String(job.id);
        optA.textContent = label;
        const optB = optA.cloneNode(true);
        compareJobA.appendChild(optA);
        compareJobB.appendChild(optB);
      });
      if (prevA) compareJobA.value = prevA;
      if (prevB) compareJobB.value = prevB;
    }

    function renderComparisonSummary(jobs) {
      if (!jobs || !jobs.length) {
        comparisonSummary.textContent = "No comparison loaded.";
        return;
      }
      clearNode(comparisonSummary);
      const row = document.createElement("div");
      row.className = "row";
      const succeeded = jobs.filter((job) => job.status === "SUCCEEDED").length;
      const failed = jobs.filter((job) =>
        ["FAILED", "QUARANTINED"].includes(job.status)
      ).length;
      row.appendChild(createPill(`Total: ${jobs.length}`));
      row.appendChild(createPill(`Succeeded: ${succeeded}`));
      row.appendChild(createPill(`Failed: ${failed}`));

      let winner = null;
      let winnerReason = "";
      const candidates = jobs.filter((job) => job.status === "SUCCEEDED");
      if (candidates.length) {
        candidates.sort((a, b) => {
          const statsA = comparisonStats.get(a.id) || {};
          const statsB = comparisonStats.get(b.id) || {};
          const artifactsA = statsA.artifacts || 0;
          const artifactsB = statsB.artifacts || 0;
          if (artifactsA !== artifactsB) return artifactsB - artifactsA;
          const coverageA = statsA.chars_per_page || 0;
          const coverageB = statsB.chars_per_page || 0;
          if (coverageA !== coverageB) return coverageB - coverageA;
          const durationA = a.duration_ms || Number.MAX_SAFE_INTEGER;
          const durationB = b.duration_ms || Number.MAX_SAFE_INTEGER;
          return durationA - durationB;
        });
        winner = candidates[0];
        winnerReason = "Most artifacts and strongest text coverage among successful runs.";
        row.appendChild(
          createPill(`Suggested: Job ${winner.id} (${winner.profile || "—"})`)
        );
      }

      comparisonSummary.appendChild(row);
      if (winnerReason) {
        const note = document.createElement("div");
        note.className = "muted";
        note.textContent = winnerReason;
        comparisonSummary.appendChild(note);
      }
    }

    function diffLines(aText, bText) {
      const maxLines = 400;
      const aLinesFull = (aText || "").split("\n");
      const bLinesFull = (bText || "").split("\n");
      const truncated = aLinesFull.length > maxLines || bLinesFull.length > maxLines;
      const aLines = aLinesFull.slice(0, maxLines);
      const bLines = bLinesFull.slice(0, maxLines);
      const maxCells = 50000;
      if (aLines.length * bLines.length > maxCells) {
        return {
          lines: [{ type: "info", text: "Diff skipped: output too large." }],
          truncated: true,
        };
      }
      const dp = Array.from({ length: aLines.length + 1 }, () =>
        Array(bLines.length + 1).fill(0)
      );
      for (let i = aLines.length - 1; i >= 0; i -= 1) {
        for (let j = bLines.length - 1; j >= 0; j -= 1) {
          if (aLines[i] === bLines[j]) {
            dp[i][j] = dp[i + 1][j + 1] + 1;
          } else {
            dp[i][j] = Math.max(dp[i + 1][j], dp[i][j + 1]);
          }
        }
      }

      const lines = [];
      let i = 0;
      let j = 0;
      while (i < aLines.length && j < bLines.length) {
        if (aLines[i] === bLines[j]) {
          lines.push({ type: "equal", text: aLines[i] });
          i += 1;
          j += 1;
        } else if (dp[i + 1][j] >= dp[i][j + 1]) {
          lines.push({ type: "remove", text: aLines[i] });
          i += 1;
        } else {
          lines.push({ type: "add", text: bLines[j] });
          j += 1;
        }
      }
      while (i < aLines.length) {
        lines.push({ type: "remove", text: aLines[i] });
        i += 1;
      }
      while (j < bLines.length) {
        lines.push({ type: "add", text: bLines[j] });
        j += 1;
      }
      return { lines, truncated };
    }

    function renderDiff(textA, textB) {
      clearNode(compareDiffPanel);
      if (!textA || !textB) {
        compareDiffPanel.textContent = "Select two jobs and load previews to see a diff.";
        return;
      }
      const result = diffLines(textA, textB);
      if (result.truncated) {
        const note = document.createElement("div");
        note.className = "muted";
        note.textContent = "Diff truncated to a limited line window.";
        compareDiffPanel.appendChild(note);
      }
      const showOnlyChanges = compareDiffOnly.checked;
      result.lines.forEach((line) => {
        if (showOnlyChanges && line.type === "equal") {
          return;
        }
        const row = document.createElement("div");
        if (line.type === "add") {
          row.style.color = "#1b6e2e";
          row.textContent = `+ ${line.text}`;
        } else if (line.type === "remove") {
          row.style.color = "#9b2c1a";
          row.textContent = `- ${line.text}`;
        } else if (line.type === "info") {
          row.className = "muted";
          row.textContent = line.text;
        } else {
          row.style.color = "#6c5f55";
          row.textContent = `  ${line.text}`;
        }
        compareDiffPanel.appendChild(row);
      });
    }

    async function loadComparisonPreviews() {
      const jobA = compareJobA.value;
      const jobB = compareJobB.value;
      const kind = compareArtifactKind.value;
      if (!jobA || !jobB) {
        setStatus("Select Job A and Job B.", true);
        return;
      }
      comparePreviewA.textContent = "Loading preview...";
      comparePreviewB.textContent = "Loading preview...";
      try {
        const [textA, textB] = await Promise.all([
          loadArtifactText(jobA, kind),
          loadArtifactText(jobB, kind),
        ]);
        if (!textA) {
          comparePreviewA.textContent = "Artifact not available for Job A.";
        } else {
          const trimmed = truncateText(textA);
          comparePreviewA.textContent = trimmed.text;
        }
        if (!textB) {
          comparePreviewB.textContent = "Artifact not available for Job B.";
        } else {
          const trimmed = truncateText(textB);
          comparePreviewB.textContent = trimmed.text;
        }
        lastDiffPayload = { textA: textA || "", textB: textB || "" };
        renderDiff(lastDiffPayload.textA, lastDiffPayload.textB);
      } catch (err) {
        comparePreviewA.textContent = "Failed to load preview.";
        comparePreviewB.textContent = "Failed to load preview.";
        compareDiffPanel.textContent = "Diff unavailable.";
      }
    }

    function clearComparisonReview() {
      compareJobA.value = "";
      compareJobB.value = "";
      compareArtifactKind.value = "markdown";
      comparePreviewA.textContent = "No preview loaded.";
      comparePreviewB.textContent = "No preview loaded.";
      compareDiffPanel.textContent = "No diff yet.";
      lastDiffPayload = null;
    }

    function renderSystem(data) {
      const cpu = data.cpu || {};
      const mem = data.memory || {};
      const disk = data.disk || {};
      const gpu = data.gpu || {};
      const load = cpu.loadavg ? cpu.loadavg.map((v) => v.toFixed(2)).join(", ") : "—";
      const gpuLine = gpu.available
        ? `gpu: ${gpu.gpus
            .map(
              (item) =>
                `${item.name} · ${item.utilization_pct}% · ${item.memory_used_mb}/${item.memory_total_mb} MB`
            )
            .join(" | ")}`
        : `gpu: ${gpu.reason || "unavailable"}`;
      const driverLine = gpu.driver_version ? `driver: ${gpu.driver_version}` : null;

      fields.system.innerHTML = `
        <div class="pill">db: ${data.checks?.db ? "ok" : "down"}</div>
        <div class="pill">broker: ${data.checks?.broker ? "ok" : "down"}</div>
        <div class="pill">cpu: ${cpu.count ?? "—"} cores · load ${load}</div>
        <div class="pill">mem: ${formatBytes(mem.used)} / ${formatBytes(mem.total)} (${formatPercent(
        mem.percent
      )})</div>
        <div class="pill">disk(/): ${formatBytes(
          disk.root?.used
        )} / ${formatBytes(disk.root?.total)} (${formatPercent(
        disk.root?.percent
      )})</div>
        <div class="pill">disk(data): ${
          disk.data_root
            ? `${formatBytes(disk.data_root.used)} / ${formatBytes(
                disk.data_root.total
              )} (${formatPercent(disk.data_root.percent)})`
            : "n/a"
        }</div>
        <div class="pill">uptime: ${formatUptime(data.uptime_seconds)}</div>
        <div class="pill">${gpuLine}</div>
        ${driverLine ? `<div class="pill">${driverLine}</div>` : ""}
      `;
      fields.metrics.textContent = data.metrics?.text || "—";
    }

    function renderJobStatus(job) {
      if (!job) {
        jobStatusPanel.textContent = "No job loaded.";
        jobActions.innerHTML = "";
        return;
      }
      const status = job.status || "—";
      const stage = job.stage || "—";
      const error = job.error_code ? `${job.error_code}: ${job.error_message || ""}` : "—";
      jobStatusPanel.innerHTML = `
        <div class="list">
          <div class="pill">Status: ${status}</div>
          <div class="pill">Stage: ${stage}</div>
          <div class="pill">External UUID: ${job.external_uuid || "—"}</div>
          <div class="pill">Profile: ${job.profile || "—"}</div>
          <div class="pill">Comparison: ${job.comparison_id || "—"}</div>
          <div class="pill">Queued: ${job.queued_at || "—"}</div>
          <div class="pill">Started: ${job.started_at || "—"}</div>
          <div class="pill">Finished: ${job.finished_at || "—"}</div>
          <div class="pill">Error: ${error}</div>
          <div class="pill">Attempts: ${job.attempt ?? "—"} / ${job.max_retries ?? "—"}</div>
        </div>
      `;
      jobActions.innerHTML = "";
      if (canRetryJob(job)) {
        const retryBtn = document.createElement("button");
        retryBtn.className = "secondary";
        retryBtn.type = "button";
        retryBtn.textContent = "Retry job";
        retryBtn.addEventListener("click", async () => {
          const updated = await retryJob(job.id);
          if (updated) {
            renderJobStatus(updated);
            if (compareIdInput.value.trim()) {
              await fetchComparison(compareIdInput.value.trim());
            }
          }
        });
        jobActions.appendChild(retryBtn);
      }
    }

    function selectedCompareProfiles() {
      return Array.from(document.querySelectorAll("input[name='compareProfiles']:checked")).map(
        (item) => item.value
      );
    }

    function selectedUploadCompareProfiles() {
      return Array.from(
        document.querySelectorAll("input[name='uploadCompareProfiles']:checked")
      ).map((item) => item.value);
    }

    function isErrorJob(job) {
      return ["FAILED", "QUARANTINED"].includes(job.status) || !!job.error_code;
    }

    function canRetryJob(job) {
      if (!job) return false;
      if (!["FAILED", "QUARANTINED"].includes(job.status)) return false;
      if (job.attempt === null || job.attempt === undefined) return true;
      if (job.max_retries === null || job.max_retries === undefined) return true;
      return job.attempt < job.max_retries;
    }

    async function retryJob(jobId) {
      if (!jobId) return;
      try {
        const res = await fetchAuthorized(`/v1/jobs/${jobId}/retry/`, {
          method: "POST",
        });
        if (!res.ok) {
          setStatus(`Retry failed (${res.status})`, true);
          return null;
        }
        const job = await res.json();
        setStatus(`Job ${job.id} re-queued.`);
        return job;
      } catch (err) {
        setStatus("Retry failed.", true);
        return null;
      }
    }

    function renderComparisonJobs(jobs) {
      clearNode(compareResult);
      if (!jobs || !jobs.length) {
        compareResult.textContent = "No comparison jobs found.";
        return;
      }
      const filtered = compareFilterErrors.checked
        ? jobs.filter((job) => isErrorJob(job))
        : jobs;
      if (!filtered.length) {
        compareResult.textContent = "No comparison jobs match the current filter.";
        return;
      }

      filtered.forEach((job) => {
        const block = document.createElement("div");
        block.className = "list";
        const row = document.createElement("div");
        row.className = "row";
        row.appendChild(createPill(`Job ${job.id}`));
        row.appendChild(createPill(`Profile: ${job.profile || "—"}`));
        row.appendChild(createPill(`Status: ${job.status || "—"}`));
        if (job.duration_ms !== null && job.duration_ms !== undefined) {
          row.appendChild(createPill(`Duration: ${formatDuration(job.duration_ms)}`));
        }
        if (job.error_code) {
          row.appendChild(createPill(`Error: ${job.error_code}`));
        }
        row.appendChild(createPill(`Attempts: ${job.attempt ?? "—"} / ${job.max_retries ?? "—"}`));

        const actions = document.createElement("div");
        actions.className = "row";
        actions.style.marginLeft = "auto";

        const setA = document.createElement("button");
        setA.className = "secondary";
        setA.type = "button";
        setA.textContent = "Set A";
        setA.addEventListener("click", () => {
          compareJobA.value = String(job.id);
        });

        const setB = document.createElement("button");
        setB.className = "secondary";
        setB.type = "button";
        setB.textContent = "Set B";
        setB.addEventListener("click", () => {
          compareJobB.value = String(job.id);
        });

        const load = document.createElement("button");
        load.className = "ghost";
        load.type = "button";
        load.textContent = "Load";
        load.addEventListener("click", () => {
          jobIdInput.value = String(job.id);
          fetchJob(job.id);
        });

        if (canRetryJob(job)) {
          const retry = document.createElement("button");
          retry.className = "secondary";
          retry.type = "button";
          retry.textContent = "Retry";
          retry.addEventListener("click", async () => {
            const updated = await retryJob(job.id);
            if (updated) {
              const index = comparisonJobs.findIndex((row) => row.id === updated.id);
              if (index >= 0) {
                comparisonJobs[index] = updated;
              }
              renderComparisonJobs(comparisonJobs);
              renderComparisonSummary(comparisonJobs);
            }
          });
          actions.appendChild(retry);
        }

        actions.appendChild(setA);
        actions.appendChild(setB);
        actions.appendChild(load);
        row.appendChild(actions);
        block.appendChild(row);

        const stats = comparisonStats.get(job.id);
        if (stats) {
          const statsRow = document.createElement("div");
          statsRow.className = "row";
          statsRow.appendChild(createPill(`Artifacts: ${stats.artifacts ?? 0}`));
          statsRow.appendChild(createPill(`Pages: ${stats.pages ?? "—"}`));
          statsRow.appendChild(createPill(`OCR pages: ${stats.ocr_pages ?? "—"}`));
          statsRow.appendChild(createPill(`Pictures: ${stats.pictures ?? "—"}`));
          statsRow.appendChild(createPill(`Tables: ${stats.tables ?? "—"}`));
          statsRow.appendChild(
            createPill(`Chars/page: ${stats.chars_per_page ?? "—"}`)
          );
          statsRow.appendChild(createPill(`Confidence: ${stats.confidence}`));
          block.appendChild(statsRow);
        } else {
          const note = document.createElement("div");
          note.className = "muted";
          note.textContent = "Loading stats…";
          block.appendChild(note);
        }

        compareResult.appendChild(block);
      });
    }

    async function fetchComparison(comparisonId) {
      if (!comparisonId) {
        setStatus("Provide a comparison id.", true);
        return;
      }
      try {
        const jobs = await fetchJson(`/v1/jobs/?comparison_id=${comparisonId}`);
        comparisonJobs = jobs;
        comparisonArtifacts.clear();
        comparisonStats.clear();
        comparisonTextCache.clear();
        renderComparisonJobs(comparisonJobs);
        populateComparisonSelects(comparisonJobs);
        comparisonSummary.textContent = "Loading comparison summary...";
        await Promise.all(comparisonJobs.map((job) => loadJobStats(job)));
        renderComparisonJobs(comparisonJobs);
        renderComparisonSummary(comparisonJobs);
      } catch (err) {
        compareResult.textContent = "Failed to load comparison jobs.";
        comparisonSummary.textContent = "Comparison summary unavailable.";
      }
    }

    async function runComparison() {
      const key = apiKeyInput.value.trim();
      if (!key) {
        setStatus("Select an API key before comparing.", true);
        return;
      }
      const documentId = compareDocumentId.value.trim();
      if (!documentId) {
        setStatus("Provide a document id to compare.", true);
        return;
      }
      const profiles = selectedCompareProfiles();
      if (!profiles.length) {
        setStatus("Select at least one profile.", true);
        return;
      }
      const payload = { profiles };
      const optionsRaw = compareOptionsJson.value.trim();
      if (optionsRaw) {
        try {
          payload.options_json = JSON.parse(optionsRaw);
        } catch (err) {
          setStatus("Options JSON is invalid.", true);
          return;
        }
      }
      compareResult.textContent = "Starting comparison...";
      try {
        const res = await fetchAuthorized(`/v1/documents/${documentId}/compare/`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        });
        if (!res.ok) {
          setStatus(`Comparison failed (${res.status})`, true);
          compareResult.textContent = "Comparison failed.";
          return;
        }
        const data = await res.json();
        compareIdInput.value = data.comparison_id || "";
        setStatus("Comparison jobs queued.");
        await fetchComparison(data.comparison_id);
      } catch (err) {
        setStatus("Comparison failed.", true);
        compareResult.textContent = "Comparison failed.";
      }
    }

    function renderArtifacts(items) {
      if (!items || !items.length) {
        artifactPanel.textContent = "No artifacts.";
        return;
      }
      artifactPanel.innerHTML = items
        .map(
          (item) => `
            <div class="row" style="justify-content: space-between;">
              <div class="mono">${item.kind} · ${item.size_bytes ?? "—"} bytes</div>
              <button class="secondary" data-artifact="${item.id}" data-kind="${item.kind}">Download</button>
            </div>
          `
        )
        .join("");
      artifactPanel.querySelectorAll("button[data-artifact]").forEach((btn) => {
        btn.addEventListener("click", () => downloadArtifact(btn.dataset.artifact, btn.dataset.kind));
      });
    }

    async function downloadArtifact(artifactId, kind) {
      try {
        const res = await fetchAuthorized(`/v1/artifacts/${artifactId}/`);
        if (!res.ok) {
          setStatus(`Artifact download failed (${res.status})`, true);
          return;
        }
        const blob = await res.blob();
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = kind || "artifact";
        document.body.appendChild(link);
        link.click();
        link.remove();
        URL.revokeObjectURL(url);
      } catch (err) {
        setStatus("Failed to download artifact.", true);
      }
    }

    async function fetchJob(jobId, withArtifacts = true) {
      if (!jobId) {
        setStatus("Provide a job id.", true);
        return;
      }
      try {
        const job = await fetchJson(`/v1/jobs/${jobId}/`);
        renderJobStatus(job);
        if (withArtifacts && job.status === "SUCCEEDED") {
          const artifacts = await fetchJson(`/v1/artifacts/?job_id=${jobId}`);
          renderArtifacts(artifacts);
        }
        if (["SUCCEEDED", "FAILED", "CANCELED", "QUARANTINED"].includes(job.status)) {
          if (pollTimer) {
            clearInterval(pollTimer);
            pollTimer = null;
            togglePollBtn.textContent = "Start polling";
          }
        }
      } catch (err) {
        renderJobStatus(null);
      }
    }

    async function uploadDocument() {
      const key = apiKeyInput.value.trim();
      if (!key) {
        setStatus("Select an API key before uploading.", true);
        return;
      }
      if (!uploadFile.files.length) {
        setStatus("Select a PDF file to upload.", true);
        return;
      }
      const form = new FormData();
      form.append("file", uploadFile.files[0]);
      if (uploadIngest.checked) {
        form.append("ingest", "true");
      }
      const externalUuid = uploadExternalUuid.value.trim();
      if (externalUuid) {
        form.append("external_uuid", externalUuid);
      }
      const profile = uploadProfile.value;
      if (profile) {
        form.append("profile", profile);
      }
      const optionsRaw = uploadOptionsJson.value.trim();
      if (optionsRaw) {
        try {
          JSON.parse(optionsRaw);
        } catch (err) {
          setStatus("Options JSON is invalid.", true);
          return;
        }
        form.append("options_json", optionsRaw);
      }

      uploadResult.textContent = "Uploading...";
      try {
        const res = await fetchAuthorized("/v1/documents/", {
          method: "POST",
          body: form,
        });
        if (!res.ok) {
          let detail = "";
          let code = "";
          try {
            const payload = await res.json();
            detail = payload.message || "";
            code = payload.error_code || "";
          } catch (err) {
            detail = "";
          }
          if (res.status === 409 && code === "DUPLICATE_DOCUMENT") {
            setStatus("Duplicate document. Use existing document/job and retry if it failed.", true);
            uploadResult.textContent =
              "Duplicate document. Open the existing job and use Retry if it failed.";
          } else {
            setStatus(`Upload failed (${res.status})`, true);
            uploadResult.textContent = detail || "Upload failed.";
          }
          return;
        }
        const payload = await res.json();
        uploadResult.innerHTML = `Document ${payload.id} · SHA ${payload.sha256 || "—"} · Job ${payload.job_id || "—"}`;
        if (payload.job_id) {
          jobIdInput.value = payload.job_id;
          await fetchJob(payload.job_id);
        }
        compareDocumentId.value = payload.id || "";
        if (uploadCompare.checked && payload.id) {
          const selectedProfiles = selectedUploadCompareProfiles();
          const profiles = selectedProfiles.length ? selectedProfiles : ALL_PROFILES.slice();
          const comparePayload = { profiles };
          const compareOptionsRaw = uploadCompareOptionsJson.value.trim();
          if (compareOptionsRaw) {
            try {
              comparePayload.options_json = JSON.parse(compareOptionsRaw);
            } catch (err) {
              setStatus("Testset options JSON is invalid.", true);
              return;
            }
          }
          compareResult.textContent = "Creating testset...";
          const compareRes = await fetchAuthorized(`/v1/documents/${payload.id}/compare/`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(comparePayload),
          });
          if (!compareRes.ok) {
            setStatus(`Testset creation failed (${compareRes.status})`, true);
            compareResult.textContent = "Testset creation failed.";
            return;
          }
          const compareData = await compareRes.json();
          compareIdInput.value = compareData.comparison_id || "";
          setStatus("Testset created. Comparison jobs queued.");
          await fetchComparison(compareData.comparison_id);
        }
      } catch (err) {
        setStatus("Upload failed.", true);
        uploadResult.textContent = "Upload failed.";
      }
    }

    function togglePolling() {
      if (pollTimer) {
        clearInterval(pollTimer);
        pollTimer = null;
        togglePollBtn.textContent = "Start polling";
        return;
      }
      const jobId = jobIdInput.value.trim();
      if (!jobId) {
        setStatus("Provide a job id before polling.", true);
        return;
      }
      togglePollBtn.textContent = "Stop polling";
      pollTimer = setInterval(() => fetchJob(jobId), 3000);
      fetchJob(jobId);
    }

    function clearUpload() {
      uploadFile.value = "";
      uploadExternalUuid.value = "";
      uploadProfile.value = "";
      uploadOptionsJson.value = "";
      uploadCompare.checked = false;
      uploadCompareOptionsJson.value = "";
      document
        .querySelectorAll("input[name='uploadCompareProfiles']:checked")
        .forEach((item) => {
          item.checked = false;
        });
      uploadIngest.checked = true;
      uploadResult.textContent = "No upload yet.";
    }

    async function refresh() {
      setStatus("Loading...");
      try {
        const [summary, workers, system] = await Promise.all([
          fetchJson("/v1/dashboard/summary"),
          fetchJson("/v1/dashboard/workers"),
          fetch("/dashboard/system").then((res) => res.json()),
        ]);
        renderSummary(summary);
        renderWorkers(workers);
        renderSystem(system);
        setStatus("Updated just now.");
        lastUpdated.textContent = new Date().toLocaleTimeString();
      } catch (err) {
        if (!apiKeyInput.value.trim()) {
          return;
        }
        setStatus("Failed to load data.", true);
      }
    }

    saveKeyBtn.addEventListener("click", () => {
      saveKey();
      refresh();
    });
    refreshBtn.addEventListener("click", refresh);
    uploadBtn.addEventListener("click", (event) => {
      event.preventDefault();
      uploadDocument();
    });
    clearUploadBtn.addEventListener("click", (event) => {
      event.preventDefault();
      clearUpload();
    });
    fetchJobBtn.addEventListener("click", (event) => {
      event.preventDefault();
      fetchJob(jobIdInput.value.trim());
    });
    togglePollBtn.addEventListener("click", (event) => {
      event.preventDefault();
      togglePolling();
    });
    compareRunBtn.addEventListener("click", (event) => {
      event.preventDefault();
      runComparison();
    });
    compareFetchBtn.addEventListener("click", (event) => {
      event.preventDefault();
      fetchComparison(compareIdInput.value.trim());
    });
    compareFilterErrors.addEventListener("change", () => {
      renderComparisonJobs(comparisonJobs);
    });
    compareDiffOnly.addEventListener("change", () => {
      if (lastDiffPayload) {
        renderDiff(lastDiffPayload.textA, lastDiffPayload.textB);
      }
    });
    compareLoadBtn.addEventListener("click", (event) => {
      event.preventDefault();
      loadComparisonPreviews();
    });
    compareClearBtn.addEventListener("click", (event) => {
      event.preventDefault();
      clearComparisonReview();
    });
    autoRefresh.addEventListener("change", () => {
      if (autoRefresh.checked) {
        setStatus("Auto-refresh enabled.");
      }
    });

    populateComparisonSelects([]);
    loadSavedKey();
    if (apiKeyInput.value.trim()) {
      refresh();
    }

    setInterval(() => {
      if (autoRefresh.checked) {
        refresh();
      }
    }, 10000);
  </script>
{% endblock %}
